## HTTP
- [HTTP](#http)
    - [1.什么是域名发散和域名收敛？](#1什么是域名发散和域名收敛)
    - [2.为什么浏览器要做并发限制呢？](#2为什么浏览器要做并发限制呢)
    - [3.什么是 DDOS 攻击](#3什么是-ddos-攻击)
    - [4.DDOS 攻击方式](#4ddos-攻击方式)
    - [5.如何应对 DDOS 攻击](#5如何应对-ddos-攻击)
    - [6.http请求过程](#6http请求过程)
    - [7.DNS 域名如何解析的？](#7dns-域名如何解析的)
    - [8.TCP三次握手](#8tcp三次握手)
    - [9.为什么要三次握手？](#9为什么要三次握手)
    - [10.为什么HTTP协议要基于TCP来实现？](#10为什么http协议要基于tcp来实现)
    - [11.什么是面相连接协议？面向无链接协议又是什么？](#11什么是面相连接协议面向无链接协议又是什么)
      - [1. 面相连接协议定义](#1-面相连接协议定义)
      - [2. 面向无链接协议定义](#2-面向无链接协议定义)
    - [12.说到三次握手，那在说下四次挥手吧？](#12说到三次握手那在说下四次挥手吧)
    - [13.为什么要四次挥手](#13为什么要四次挥手)
    - [14.为什么建立连接是三次握手，关闭连接确是四次挥手呢？](#14为什么建立连接是三次握手关闭连接确是四次挥手呢)
    - [15.如果已经建立了连接，但是客户端突然出现故障了怎么办？](#15如果已经建立了连接但是客户端突然出现故障了怎么办)
    - [16.http请求方式有哪些？](#16http请求方式有哪些)
    - [17.常用的请求状态码？](#17常用的请求状态码)
    - [18.TCP和UDP的区别以及应用场景](#18tcp和udp的区别以及应用场景)
      - [1.UDP](#1udp)
      - [2.TCP](#2tcp)
      - [3.应用场景](#3应用场景)
    - [19.GET和POST的区别](#19get和post的区别)
    - [20.什么是Http无状态？Session、Cookie、Token三者之间的区别](#20什么是http无状态sessioncookietoken三者之间的区别)
    - [21.HTTP、状态码：](#21http状态码)
    - [22.Internet采用哪种网络协议?该协议的主要层次结构?](#22internet采用哪种网络协议该协议的主要层次结构)
    - [23.IP地址的编码分为哪俩部分?](#23ip地址的编码分为哪俩部分)
    - [24.TCP/IP通信建立的过程怎样，端口有什么作用？](#24tcpip通信建立的过程怎样端口有什么作用)
    - [25.IP组播有那些好处?](#25ip组播有那些好处)
    - [参考链接](#参考链接)


#### 1.什么是域名发散和域名收敛？

1、域名发散
为了突破浏览器对于同一域名并发请求数的限制，http 静态资源采用多个子域名，通常为2～4个。
目的是充分利用现代浏览器的多线程并发下载能力。
2、域名收敛
域名收敛和域名发散正好相反：就是将静态资源只放在一个域名下面，而非发散情况下的多个域名下。
主要是为了适应移动端的发展需求。

#### 2.为什么浏览器要做并发限制呢？

1.以前网速慢、服务器硬件设备差、负载能力差，容易崩溃，所以要对最大并发数进行限制

#### 3.什么是 DDOS 攻击

分布式拒绝服务攻击(Distributed denial of service attack)

向目标系统同时提出数量庞大的服务请求。

#### 4.DDOS 攻击方式

1.通过使网络过载来干扰甚至阻断正常的网络通讯；

2.通过向服务器提交大量请求，使服务器超负荷；

3.阻断某一用户访问服务器；

4.阻断某服务与特定系统或个人的通讯。

#### 5.如何应对 DDOS 攻击

黑名单
DDOS 清洗：对用户请求数据进行实时监控，及时发现DOS攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。
CDN 加速
高防服务器：高防服务器主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点

#### 6.http请求过程

1.对www.abc.com这个网址进行DNS域名解析，得到对应的IP地址

2.根据这个IP，找到对应的服务器，发起TCP的三次握手

3.建立TCP连接后发起HTTP请求

4.服务器响应HTTP请求，浏览器得到html代码

5.浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）（先得到html代码，才能去找这些资源，网页需要先构建DOM和CSSOM）

6.浏览器对页面进行渲染呈现给用户

7.服务器关闭关闭TCP连接

![](https://gitee.com/WebInterviewHub/WebInterview/raw/master/imgs/http6.png)

#### 7.DNS 域名如何解析的？

DNS域名解析采用的是递归查询的方

先去找DNS缓存->缓存找不到就去找根域名服务器->根域名又会去找下一级，递归查找之后，找到了，给我们的web浏览器。

- DNS解析过程：
  - 本地的hosts文件
  - 本地DNS解析器缓存
  - 本地DNS服务器（TCP/ip参数中设置的首选DNS服务器）
  - 未用转发模式：根DNS -> 下一级DNS
  - 转发模式：上一级DNS -> 根DNS -> 目标DNS

1.浏览器首先搜索自身的DNS缓存，看缓存中是否有 www.abc.com 这个域名，有而且没有过期的话，解析结束。

2.如果浏览器自身的缓存中没有找到，则会搜索操作系统自身的DNS缓存，如果找到且没有过期则停止搜索，解析到此结束。

3.如果在操作系统的DNS缓存中也没有找到，那么尝试读取hosts文件，有则解析成功，解析到此结束。

4.如果在hosts文件中也没有找到，浏览器会发起一个DNS（Domain Name System：域名服务协议）系统调用，向本地配置的首选DNS服务器（TCP/ip参数中设置的首选DNS服务器）发起域名解析请求 （递归请求）

  4.1.运营商的DNS服务器首先查找自身的缓存，如果能找到且没有过期则解析成功。

  4.2.如果没有找到，则运营商的DNS代我们的浏览器发起迭代DNS解析请求。

  4.3.运营商DNS首先会查找根域DNS的IP地址（这个DNS服务器内置13台根DNS域服务器的IP地址），找到根域的DNS地址，就会向其发起请求（（问一下www.abc.com这个域名的ip地址是多少啊？））。根域发现这是一个com域（顶级域）的域名，于是返回com域的IP地址，然后运营商的DNS就得到com域的IP地址。

4.运营商的DNS得到com域的IP地址之后又向com域的IP地址发起地址请求（问一下www.abc.com这个域名的IP地址是多少啊？）。com域这台服务器告诉运营商的DNS我不知道www.abc.com这个域名的IP地址，但是我知道abc.com这个域名的DNS地址，你去找它吧。

5.运营商的DNS又向abc.com这个域名的DNS地址发起请求，（问一下www.abc.com这个域名的IP地址是多少？）

6.这个时候abc.com域的DNS服务器在本地查找。

7.把找到的结果发给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.abc.com对应的IP地址，并返回给Windows系统内核，内核就把这个结果返回给浏览器，最终浏览器得到这个IP地址，进行下一步动作。

#### 8.TCP三次握手

1.客服端首先发送一个连接试探 SYN。

2.服务器监听到连接请求报文后，如果同意建立连接，则向Client发送确认ACK和SYN。

3.Client收到确认后还需要再次发送确认ACK，同时携带要发送给Server的数据。

#### 9.为什么要三次握手？

1.验证服务端和客户端是否遵循TCP/IP协议

2.为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

#### 10.为什么HTTP协议要基于TCP来实现？

TCP是一个**端到端**的**可靠的****面相连接**的协议，HTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，会重传）

#### 11.什么是面相连接协议？面向无链接协议又是什么？

##### 1. 面相连接协议定义

通信双方在通信时，要事先建立好一条通信线路（虚拟的）。

其过程有建立连接、维护连接、释放（断开）连接三个过程。

```
TCP是面向连接的
```

##### 2. 面向无链接协议定义

与面向连接相对，面向无连接是指通信双方不需要事先建立通信线路，而是把每个带有目的地址的报文分组送到线路上，由系统自主选定线路进行传输。

面向无连接只有**“传送数据”**的过程。

```
UDP是面向无连接的
```

#### 12.说到三次握手，那在说下四次挥手吧？

1.客户端进程发出连接释放报文FIN，并且停止发送数据。

2.服务器收到连接释放报文，发出确认报文ACK，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。(客户端向服务器方向释放了，但是服务器发送数据，客户端依然要接受)

3.客户端收到服务器的确认请求后，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。

4.服务器将最后的数据发送完毕后，就向客户端发送连接释放报文FIN，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

5.客户端收到服务器的连接释放报文后，必须发出确认ACK，客户端就进入了TIME-WAIT（时间等待）状态。

6.服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。（服务器结束TCP连接的时间要比客户端早一些。）

#### 13.为什么要四次挥手

TCP协议是一种**面向连接的、可靠的、基于字节流**的*传输层*通信协议。TCP是**全双工模式**，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。

#### 14.为什么建立连接是三次握手，关闭连接确是四次挥手呢？

建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

- [一文带你彻底了解 TCP 连接的本质](https://xie.infoq.cn/article/5d3416c3bf7c735fb3d4a880d)

#### 15.如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器。但是客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为**2小时**，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后**每隔75秒**发送一次。若**一连发送10个**探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

#### 16.http请求方式有哪些？

1.GET：请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据。

2.HEAD：请求一个与GET请求的响应相同的响应，但没有响应体。

3.POST：将实体提交到指定的资源。

4.PUT：请求有效载荷替换目标资源的所有当前表示。

5.DELETE：删除指定的资源。

6.OPTIONS：用于描述目标资源的通信选项。

7.PATCH：对资源应用部分修改。

8.CONNECT：建立一个到由目标资源标识的服务器的隧道。

9.TRACE：沿着到目标资源的路径执行一个消息环回测试。

#### 17.常用的请求状态码？

![](https://gitee.com/WebInterviewHub/WebInterview/raw/master/imgs/http17.png)

![](https://gitee.com/WebInterviewHub/WebInterview/raw/master/imgs/http17-1.png)

![](https://gitee.com/WebInterviewHub/WebInterview/raw/master/imgs/http17-2.png)




#### 18.TCP和UDP的区别以及应用场景

##### 1.UDP

1.UDP在传输层上

2.是面向无连接的

3.不需要建立可靠的连接

4.是面向**报文**

5.限制就是发送一些比较小的包文件，而且没有错误处理机制。包没了就是没了。可以做一些处理，比如超时重发

6.一对一、一对多、多对一、多对多通信

7.适用于实时应用：QQ视频、微信视频等。

##### 2.TCP

1.TCP在传输层上

2.是TCP是面向连接的

3.可以互相信任的进行数据发送，这样的保密性强一些

4.面向**字节流**

5.一对一通信

6.适用于可靠传输的应用

##### 3.应用场景

![](https://gitee.com/WebInterviewHub/WebInterview/raw/master/imgs/http18.png)



#### 19.GET和POST的区别

  简单来说：**GET产生一个TCP数据包，POST产生两个TCP数据包**
  
  严格的说：对于GET方式的请求，游览器会把http header和data一并发送出去，服务器响应200（返回数据）；
  
  而对于POST请求。游览器先发送header，服务器响应**100 continue**，游览器再发送data，服务器响应200 ok（返回数据）
  
  注：千万别说什么POST比GET安全什么的。这样一下子面试官就知道你的底子了。

#### 20.什么是Http无状态？Session、Cookie、Token三者之间的区别

[什么是Http无状态？Session、Cookie、Token三者之间的区别](https://www.cnblogs.com/lingyejun/p/9282169.html)

HTTP无状态协议，是指协议**对于交互性场景没有记忆能力**。为了解决该问题，使用cookie和session机制解决。
- Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。
- 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。
- 如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。
- Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。

Session和Cookie的关系
- cookie 是一个实际存在的、具体的东西，http 协议中定义在 header 中的字段。
- session 是一个抽象概念、开发者为了实现中断和继续等操作，将client和server之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 session 的概念。
- 即session描述的是一种通讯会话机制，而cookie只是目前实现这种机制的主流方案里面的一个参与者，它一般是用于保存session ID。

cookies机制和session机制的区别：

　1、cookies数据保存在客户端。session数据保存在服务端

　2、cookies可以减轻服务器压力，但是不安全，容易进行cookies欺骗

　3、session安全一点，但是占用服务器资源。

#### 21.HTTP、状态码：

　200：成功

　　302：重定向

　　400：请求没有进入到后台服务里（一般都是前端的锅）

　　403：禁止访问

　　404：请求失败，请求希望得到的资源未被在服务器发现。（只要不是新手写的demo，一般404都是你路径写错了，或者未区分大小写啥的）

　　502：无效的响应（基本上就是Tomcat没启好）


#### 22.Internet采用哪种网络协议?该协议的主要层次结构?

TCP/IP协议(Transmission Control Protocol/Internet Protocol)叫做传输控制/网际协议，又叫网络通讯协议，这个协议是Internet国际互联网络的基础。


TCP/IP是用于计算机通信的一组协议，我们通常称它为TCP/IP协议族。
TCP/IP是网络中使用的基本的通信协议。虽然从名字上看TCP/IP包括两个协议，传输控制协议(TCP)和网际协议(IP)，但TCP/IP实际上是一组协议，它包括TCP、IP、UDP、ICMP、RIP、TELNET、FTP、SMTP、ARP、TFTP等许多协议，这些协议一起称为TCP/IP协议。
TCP/IP由四个层次组成：**数据链路层、网络层、传输层、应用层**。

- 数据链路层
这是TCP/IP软件的最低层，负责接收IP数据报并通过网络发送，或者从网络上接收物理帧，抽出IP数据报，交给IP层。
- 网络层
负责相邻计算机之间的通信。其功能包括三方面:
a、处理来自传输层的分组发送请求，收到请求后，将分组装入IP数据报，填充报头，选择去往信宿机的路径，然后将数据报发往适当的网络接口。
b、处理输入数据报：首先检查其合法性，然后进行寻径–假如该数据报已到达信宿机，则去掉报头，将剩下部分交给适当的传输协议；假如该数据报尚未到达信宿，则转发该数据报。
c、处理路径、流控、拥塞等问题。
- 传输层
提供应用程序间的通信。其功能包括：
a、格式化信息流；
b、提供可靠传输。为实现后者，传输层协议规定接收端必须发回确认，并且假如分组丢失，必须重新发送。
- 应用层
向用户提供一组常用的应用程序，比如电子邮件、文件传输访问、远程登录等。远程登录TELNET使用TELNET协议提供在网络其它主机上注册的接口。TELNET会话提供了基于字符的虚拟终端。文件传输访问FTP使用FTP协议来提供网络内机器间的文件拷贝功能。
- OSI七层模型与TCP/IP协议的对应关系。
  - OSI中的层 功能 TCP/IP协议族
    应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet
    表示层 数据格式化，代码转换，数据加密 没有协议
    会话层 解除或建立与别的接点的联系 没有协议
    传输层 提供端对端的接口 TCP，UDP
    网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP
    数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU
    物理层 以二进制数据形式在物理媒体上传输数据

- TCP/IP协议中一些常用协议英文名：
  TCP(Transmission Control Protocol)传输控制协议
  IP(Internet Protocol)网际协议
  UDP(User Datagram Protocol)用户数据报协议
  ICMP(Internet Control Message Protocol)互联网控制信息协议
  SMTP(Simple Mail Transfer Protocol)简单邮件传输协议
  SNMP(Simple Network manage Protocol)简单网络管理协议
  FTP(File Transfer Protocol)文件传输协议
  ARP(Address Resolation Protocol)地址解析协议

  Internet物理地址和IP地址转换采用什么协议?
    ARP (Address Resolution Protocol)(地址解析协议)。

#### 23.IP地址的编码分为哪俩部分?

IP地址由两部分组成：**网络号和主机号**。不过是要和“子网掩码”按位与上之后才能区分哪些是网络位哪些是主机位。

#### 24.TCP/IP通信建立的过程怎样，端口有什么作用？

TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:

- 位码即tcp标志位,有6种标示:
  SYN(synchronous建立联机)
  ACK(acknowledgement 确认)
  PSH(push传送)
  FIN(finish结束)
  RST(reset重置)
  URG(urgent紧急)
  Sequence number(顺序号码)
  Acknowledge number(确认号码)

- 客户端TCP状态迁移：
  CLOSED->SYN_SENT->ESTABLISHED->FIN_WAIT_1->FIN_WAIT_2->TIME_WAIT->CLOSED
- 服务器TCP状态迁移：
  CLOSED->LISTEN->SYN收到->ESTABLISHED->CLOSE_WAIT->LAST_ACK->CLOSED


- 各个状态的意义如下：
  LISTEN - 侦听来自远方TCP端口的连接请求；
  SYN-SENT -在发送连接请求后等待匹配的连接请求；
  SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认；
  ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；
  FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；
  FIN-WAIT-2 - 从远程TCP等待连接中断请求；
  CLOSE-WAIT - 等待从本地用户发来的连接中断请求；
  CLOSING -等待远程TCP对连接中断的确认；
  LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认；
  TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认；
  CLOSED - 没有任何连接状态；

- TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接，如图1所示。

（1）第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。

（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。

（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。

完成三次握手，客户端与服务器开始传送数据。

确认号：其数值等于发送方的发送序号 +1(即接收方期望接收的下一个序列号)。

- TCP的包头结构：
  - 第一次握手:
    客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。
  - 第二次握手:
    服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1。同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1，即X+1。
  - 第三次握手.
    客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1

- 深入理解TCP连接的释放：
  - 由于TCP连接是**全双工**的，一个TCP连接存在双向的读写通道，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。*首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭*。
  - CP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。
（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。
（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。
（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。

  - 简单说来是 “先关读，后关写”，一共需要四个阶段。以客户机发起关闭连接为例：
1.服务器读通道关闭
2.客户机写通道关闭
3.客户机读通道关闭
4.服务器写通道关闭
关闭行为是在发起方数据发送完毕之后，给对方发出一个FIN（finish）数据段。直到接收到对方发送的FIN，且对方收到了接收确认ACK之后，双方的数据通信完全结束，过程中每次接收都需要返回确认数据段ACK。
详细过程：
第一阶段 客户机发送完数据之后，向服务器发送一个FIN数据段，序列号为i；
1.服务器收到FIN(i)后，返回确认段ACK，序列号为i+1，关闭服务器读通道；
2.客户机收到ACK(i+1)后，关闭客户机写通道；
（此时，客户机仍能通过读通道读取服务器的数据，服务器仍能通过写通道写数据）
第二阶段 服务器发送完数据之后，向客户机发送一个FIN数据段，序列号为j；
3.客户机收到FIN(j)后，返回确认段ACK，序列号为j+1，关闭客户机读通道；
4.服务器收到ACK(j+1)后，关闭服务器写通道。
这是标准的TCP关闭两个阶段，服务器和客户机都可以发起关闭，完全对称。

  FIN标识是通过发送最后一块数据时设置的，标准的例子中，服务器还在发送数据，所以要等到发送完的时候，设置FIN（此时可称为TCP连接处于半关闭状态，因为数据仍可从被动关闭一方向主动关闭方传送）。如果在服务器收到FIN(i)时，已经没有数据需要发送，可以在返回ACK(i+1)的时候就设置FIN(j)标识，这样就相当于可以合并第二步和第三步。

- TCP的TIME_WAIT和Close_Wait状态
  除了ESTABLISHED，可以看到连接数比较多的几个状态是：FIN_WAIT1, TIME_WAIT, CLOSE_WAIT, SYN_RECV和LAST_ACK；下面的文章就这几个状态的产生条件、对系统的影响以及处理方式进行简单描述。
- 下面看下大家一般比较关心的三种TCP状态:
  - SYN_RECV : 服务端收到建立连接的SYN没有收到ACK包的时候处在SYN_RECV状态。有两个相关系统配置：
  - CLOSE_WAIT: 发起TCP连接关闭的一方称为client，被动关闭的一方称为server。被动关闭的server收到FIN后，但未发出ACK的TCP状态是CLOSE_WAIT。出现这种状况一般都是由于server端代码的问题，如果你的服务器上出现大量CLOSE_WAIT，应该要考虑检查代码。
  - TIME_WAIT： 根据TCP协议定义的3次握手断开连接规定,发起socket主动关闭的一方 **socket**将进入TIME_WAIT状态。TIME_WAIT状态将持续**2个MSL**(Max Segment Lifetime),在Windows下**默认为4分钟，即240秒**。TIME_WAIT状态下的socket不能被回收使用. 具体现象是对于一个处理大量短连接的服务器,如果是由服务器主动关闭客户端的连接，将导致服务器端存在大量的处于TIME_WAIT状态的socket， 甚至比处于Established状态下的socket多的多,严重影响服务器的处理能力，甚至耗尽可用的socket，停止服务。
- 为什么需要TIME_WAIT？TIME_WAIT是TCP协议用以保证被重新分配的socket不会受到之前残留的延迟重发报文影响的机制,是必要的逻辑保证。
  为了方便描述，我给这个TCP连接的一端起名为Client，给另外一端起名为Server。上图描述的是Client主动关闭的过程，FTP协议中就这样的。如果要描述Server主动关闭的过程，只要交换描述过程中的Server和Client就可以了，HTTP协议就是这样的。

- 描述过程：
  - Client调用close()函数，给Server发送FIN，请求关闭连接；Server收到FIN之后给Client返回确认ACK，同时关闭读通道（不清楚就去看一下shutdown和close的差别），也就是说现在不能再从这个连接上读取东西，现在read返回0。此时Server的TCP状态转化为CLOSE_WAIT状态。
  - Client收到对自己的FIN确认后，关闭 写通道，不再向连接中写入任何数据。
  - 接下来Server调用close()来关闭连接，给Client发送FIN，Client收到后给Server回复ACK确认，同时Client关闭读通道，进入TIME_WAIT状态。
  - Server接收到Client对自己的FIN的确认ACK，关闭写通道，TCP连接转化为CLOSED，也就是关闭连接。
  - Client在TIME_WAIT状态下要等待最大数据段生存期的两倍，然后才进入CLOSED状态，TCP协议关闭连接过程彻底结束。
- 以上就是TCP协议关闭连接的过程，现在说一下TIME_WAIT状态。
从上面可以看到，主动发起关闭连接的操作的一方将达到TIME_WAIT状态，而且这个状态要保持Maximum Segment Lifetime的两倍时间。为什么要这样做而不是直接进入CLOSED状态？
  原因有二：
  一、保证TCP协议的全双工连接能够可靠关闭
  二、保证这次连接的重复数据段从网络中消失

先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够**保证对方收到ACK，最后正确的关闭连接**。

再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以**保证本次连接的所有数据都从网络中消失**。

#### 25.IP组播有那些好处?

Internet上产生的许多新的应用，特别是高带宽的多媒体应用，带来了带宽的急剧消耗和网络拥挤问题。组播是一种**允许一个或多个发送者(组播源)发送单一的数据包到多个接收者**(一次的，同时的)的网络技术。组播可以大大的节省网络带宽，因为无论有多少个目标地址，在整个网络的任何一条链路上只传送单一的数据包。所以说组播技术的核心就是针对如何节约网络资源的前提下保证服务质量。

#### 参考链接

https://www.cnblogs.com/cbslock/p/10139160.html

https://blog.csdn.net/yicixing7/article/details/79320821

https://www.cnblogs.com/6J2B2/p/12980363.html
